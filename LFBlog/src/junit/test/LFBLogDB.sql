-- MySQL dump 10.13  Distrib 5.5.40, for Win64 (x86)
--
-- Host: localhost    Database: LFBlog
-- ------------------------------------------------------
-- Server version	5.5.40

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `blog_category`
--

DROP TABLE IF EXISTS `blog_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT,
  `category_name` varchar(100) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`category_id`),
  KEY `FK6E3834FBA0BB3879` (`user_id`),
  CONSTRAINT `FK6E3834FBA0BB3879` FOREIGN KEY (`user_id`) REFERENCES `blog_user` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_category`
--

LOCK TABLES `blog_category` WRITE;
/*!40000 ALTER TABLE `blog_category` DISABLE KEYS */;
INSERT INTO `blog_category` VALUES (1,'struts2',1),(2,'hibernate',1),(3,'spring',1),(4,'java基础',1);
/*!40000 ALTER TABLE `blog_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_commit`
--

DROP TABLE IF EXISTS `blog_commit`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_commit` (
  `commit_id` int(11) NOT NULL AUTO_INCREMENT,
  `commit_name` varchar(100) DEFAULT NULL,
  `commit_email` varchar(100) DEFAULT NULL,
  `commit_content` varchar(10000) DEFAULT NULL,
  `content_id` int(11) DEFAULT NULL,
  `commit_date` date DEFAULT NULL,
  PRIMARY KEY (`commit_id`),
  KEY `FK747C7C7459961C1B` (`content_id`),
  CONSTRAINT `FK747C7C7459961C1B` FOREIGN KEY (`content_id`) REFERENCES `blog_content` (`content_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_commit`
--

LOCK TABLES `blog_commit` WRITE;
/*!40000 ALTER TABLE `blog_commit` DISABLE KEYS */;
INSERT INTO `blog_commit` VALUES (1,'lfsenior','','就是这么的霸气',1,'2017-10-12'),(2,'就是这样','','那你好棒棒哦',1,'2017-10-12'),(3,'lfsenior','','哦，不错哦',1,'2017-10-12'),(4,'lfsenior','','那你好棒棒哦',1,'2017-10-12');
/*!40000 ALTER TABLE `blog_commit` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_content`
--

DROP TABLE IF EXISTS `blog_content`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_content` (
  `content_id` int(11) NOT NULL AUTO_INCREMENT,
  `content_title` varchar(100) DEFAULT NULL,
  `content_date` date DEFAULT NULL,
  `content_body` longtext,
  `user_id` int(11) DEFAULT NULL,
  `content_label` varchar(100) DEFAULT NULL,
  `content_visit` varchar(100) DEFAULT NULL,
  `content_describe` varchar(5000) DEFAULT NULL,
  PRIMARY KEY (`content_id`),
  KEY `FK1B2448DCA0BB3879` (`user_id`),
  CONSTRAINT `FK1B2448DCA0BB3879` FOREIGN KEY (`user_id`) REFERENCES `blog_user` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_content`
--

LOCK TABLES `blog_content` WRITE;
/*!40000 ALTER TABLE `blog_content` DISABLE KEYS */;
INSERT INTO `blog_content` VALUES (1,'java.lang.StackOverflowError at org.hibernate.collection.AbstractPersistentCollection.initialize(Ab','2017-08-22','<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong><a target=\"_blank\" href=\"http://lib.csdn.net/base/java\" class=\"replace_word\" title=\"Java 知识库\" style=\"color:rgb(223,52,52); text-decoration:none; font-family:Arial; font-size:18px; font-weight:bold\">Java</a><span style=\"font-family:Arial; font-size:18px\">.lang.StackOverflowError错误如下：</span><br> </strong></span></p> \n<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong><span style=\"font-family:Arial; font-size:18px\"><span style=\"color:rgb(255,0,0); font-family:Arial; font-size:18px\">原因是两个对象的toString方法重写之后，应用程序递归太深了，所以发生了堆栈溢出。</span><br> </span></strong></span></p> \n<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong><span style=\"font-family:Arial; font-size:18px\"><img src=\"http://img.blog.csdn.net/20170822151234748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </span></strong></span></p> \n<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong>解决方法：</strong></span></p> \n<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong><span style=\"white-space:pre\"></span>可以将多的一方对象里面重写的toString方法去掉，或者两个对象里面重写的toString方法都去掉。</strong></span></p> \n<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px\"> <span style=\"font-size:18px; color:rgb(255,0,0)\"><strong>注意：两个对象里面的tostring都去掉的话，打印出来不方便查看，所以建议去掉一方。</strong></span></p> \n<br>',1,'原创','67','Java.lang.StackOverflowError错误如下： 原因是两个对象的toString方法重写之后，应用程序递归太深了，所以发生了堆栈溢出。 解决方法： 可以将多的一方对象里面重写的toString方法去掉，或者两个对象里面重写的toString方法都去掉。 注意：两个对象里面的tostring都去掉的话，打印出来不方便查看，所以建议去掉一方。'),(2,'org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.Single','2017-08-22','<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">Caused by: org.<a target=\"_blank\" href=\"http://lib.csdn.net/base/javaee\" class=\"replace_word\" title=\"Java EE知识库\" style=\"color:rgb(223,52,52); text-decoration:none; font-weight:bold\">hibernate</a>.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister&nbsp;</span></p> \n<span style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">at org.hibernate.persister.internal.PersisterFactoryImpl.create(PersisterFactoryImpl.java:185)&nbsp;<br> at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:135)&nbsp;<br> at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:385)&nbsp;<br> at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1769)&nbsp;<br> at util.HibernateUtil.buildSessionFactory(HibernateUtil.java:19)&nbsp;<br> at util.HibernateUtil.&lt;clinit&gt;(HibernateUtil.java:13)&nbsp;<br> ... 1 more&nbsp;<br> Caused by: org.hibernate.HibernateException: Unable to instantiate default tuplizer [org.hibernate.tuple.entity.PojoEntityTuplizer]&nbsp;<br> at org.hibernate.tuple.entity.EntityTuplizerFactory.constructTuplizer(EntityTuplizerFactory.java:138)&nbsp;<br> at org.hibernate.tuple.entity.EntityTuplizerFactory.constructDefaultTuplizer(EntityTuplizerFactory.java:188)&nbsp;<br> at org.hibernate.tuple.entity.EntityMetamodel.&lt;init&gt;(EntityMetamodel.java:341)&nbsp;<br> at org.hibernate.persister.entity.AbstractEntityPersister.&lt;init&gt;(AbstractEntityPersister.java:507)&nbsp;<br> at org.hibernate.persister.entity.SingleTableEntityPersister.&lt;init&gt;(SingleTableEntityPersister.java:146)&nbsp;<br> at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)&nbsp;<br> at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)&nbsp;<br> at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)&nbsp;<br> at java.lang.reflect.Constructor.newInstance(Constructor.java:513)&nbsp;<br> at org.hibernate.persister.internal.PersisterFactoryImpl.create(PersisterFactoryImpl.java:163)&nbsp;<br> ... 6 more&nbsp;<br> Caused by: java.lang.reflect.InvocationTargetException&nbsp;<br> at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)&nbsp;<br> at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)&nbsp;<br> at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)&nbsp;<br> at java.lang.reflect.Constructor.newInstance(Constructor.java:513)&nbsp;<br> at org.hibernate.tuple.entity.EntityTuplizerFactory.constructTuplizer(EntityTuplizerFactory.java:135)&nbsp;<br> ... 15 more&nbsp;<br> Caused by: org.hibernate.PropertyNotFoundException: Could not find a getter for teamName in class set.Team<br> at org.hibernate.property.BasicPropertyAccessor.createGetter(BasicPropertyAccessor.java:316)&nbsp;<br> at org.hibernate.property.BasicPropertyAccessor.getGetter(BasicPropertyAccessor.java:310)&nbsp;<br> at org.hibernate.mapping.Property.getGetter(Property.java:321)&nbsp;<br> at org.hibernate.tuple.entity.PojoEntityTuplizer.buildPropertyGetter(PojoEntityTuplizer.java:436)&nbsp;<br> at org.hibernate.tuple.entity.AbstractEntityTuplizer.&lt;init&gt;(AbstractEntityTuplizer.java:200)&nbsp;<br> at org.hibernate.tuple.entity.PojoEntityTuplizer.&lt;init&gt;(PojoEntityTuplizer.java:82)&nbsp;<br> ... 20 more</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">这个异常不太好判断。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">这个debug进去也不知道到底怎么回事。只知道是反射获取实体类对象时出了错。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">在网上查了一下， 大概有以下几种原因：&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">1. 实体类的属性对象没有设置setter或者getter。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">http://stackoverflow.com/questions/18042247/could-not-get-constructor-for-org-hibernate-persister-entity-singletableentitype&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">2. 没有导入javassist的jar文件&nbsp; (javassist-3.15.0-GA.jar什么的）&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">http://blog.csdn.net/xiaochangwei789/article/details/7712725&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">3. 我这次出错的原因。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">我的实体类中的属性对象名和映射文件的property name不一致。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">private String&nbsp;</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">team_name</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">;&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">&lt;property name=\"</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">team</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">\" column=\"team_name\" type=\"string\"/&gt;&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">这里只要改成：&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">private String team_name;&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">&lt;property name=\"team_name\"...&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\">就好了。&nbsp;</span><br style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25.1875px\"> </span>',1,'原创','91','Caused by: org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister  at org.hibernate.persister.internal.PersisterFactoryImpl.create(Pers'),(3,'【Hibernate】设置inverse属性，在多对多种维护关联关系的影响？','2017-08-21','<br> 1） 保存数据\n<br> 有影响。\n<br> \n<span style=\"white-space:pre\"></span>inverse=false ，有控制权，可以维护关联关系； 保存数据的时候会把对象关系插入中间表；\n<br> \n<span style=\"white-space:pre\"></span>inverse=true, &nbsp;没有控制权， 不会往中间表插入数据。\n<br> 2） 获取数据\n<br> \n<span style=\"white-space:pre\"></span>无。\n<br> \n<br> \n<br> 3） 解除关系\n<br> \n<span style=\"white-space:pre\"></span>// 有影响。\n<br> \n<span style=\"white-space:pre\"></span>// inverse=false ,有控制权， 解除关系就是删除中间表的数据。\n<br> \n<span style=\"white-space:pre\"></span>// inverse=true, 没有控制权，不能解除关系。\n<br> 4） 删除数据\n<br> \n<span style=\"white-space:pre\"></span>有影响。\n<br> \n<span style=\"white-space:pre\"></span>// inverse=false, 有控制权。 先删除中间表数据，再删除自身。\n<br> \n<span style=\"white-space:pre\"></span>// inverse=true, 没有控制权。 如果删除的数据有被引用，会报错！ 否则，才可以删除',1,'原创','244','1） 保存数据 有影响。 inverse=false ，有控制权，可以维护关联关系； 保存数据的时候会把对象关系插入中间表； inverse=true,  没有控制权， 不会往中间表插入数据。 2） 获取数据 无。 3） 解除关系 // 有影响。 // inverse=false ,有控制权， 解除关系就是删除中间表的数据。 // inverse=true, 没有控制权，不能解除关系。 4） 删除'),(4,'【Hibernate】多对多映射','2017-08-21','<h2><br> </h2> \n<p>需求：项目与开发人员</p> \n<p>&nbsp;&nbsp;Project &nbsp;&nbsp;Developer</p> \n<p>&nbsp;&nbsp;<span style=\"font-family:宋体\">电商系统</span></p> \n<p>&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">曹吉</span></p> \n<p>&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">王春</span></p> \n<p>&nbsp;&nbsp;&nbsp;OA<span style=\"font-family:宋体\">系统</span></p> \n<p>王春</p> \n<p>老张</p> \n<p>数据库</p> \n<p>&nbsp;<img src=\"http://img.blog.csdn.net/20170821191020219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p>&nbsp;</p> \n<h3><strong>代码</strong></h3> \n<div>\n <strong></strong>\n <pre code_snippet_id=\"2544475\" snippet_file_name=\"blog_20170821_1_3131259\" name=\"code\" class=\"java\">/**\n * 开发人员\n *\n *\n */\npublic class Developer {\nprivate int d_id;\nprivate String d_name;\n// 开发人员，参数的多个项目\nprivate Set&lt;Project&gt; projects = new HashSet&lt;Project&gt;();\n}</pre>\n <br> \n <br> \n</div> \n<div>\n <strong></strong>\n <pre code_snippet_id=\"2544475\" snippet_file_name=\"blog_20170821_2_4799699\" name=\"code\" class=\"java\">/**\n * 项目\n *\n *\n */\npublic class Project {\nprivate int prj_id;\nprivate String prj_name;\n// 项目下的多个员工\nprivate Set&lt;Developer&gt; developers = new HashSet&lt;Developer&gt;();</pre>\n <br> \n <br> \n</div> \n<div>\n <strong><br> </strong>\n</div> \n<div>\n <strong>Project.hbm.xml<br> </strong>\n</div> \n<div>\n <strong></strong>\n <pre code_snippet_id=\"2544475\" snippet_file_name=\"blog_20170821_3_8769433\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n \n&lt;hibernate-mapping package=\"cn.itcast.c_many2many\"&gt;\n&lt;class name=\"Project\" table=\"t_project\"&gt;\n&lt;id name=\"prj_id\"&gt;\n&lt;generator class=\"native\"&gt;&lt;/generator&gt;\n&lt;/id&gt;\n&lt;property name=\"prj_name\" length=\"20\"&gt;&lt;/property&gt;\n&lt;!--\n多对多映射:\n1.  映射的集合属性： “developers”\n2.  集合属性，对应的中间表： “t_relation”\n3. 外键字段，项目对应的中间表字段:  prjId\n4. 外键字段，开发者对应的中间表字段:  did\n5.   集合属性元素的类型\n --&gt;\n &lt;set name=\"developers\" table=\"t_relation\" cascade=\"save-update\"&gt;\n 	&lt;key column=\"prjId\"&gt;&lt;/key&gt;\n 	&lt;many-to-many column=\"did\" class=\"Developer\"&gt;&lt;/many-to-many&gt;\n &lt;/set&gt;\n \n&lt;/class&gt;\n \n&lt;/hibernate-mapping&gt;\n </pre>\n <br> \n <br> \n</div> \n<div>\n <strong>Developer.hbm.xml<br> </strong>\n</div> \n<div>\n <strong><br> </strong>\n</div> \n<div>\n <strong></strong>\n <pre code_snippet_id=\"2544475\" snippet_file_name=\"blog_20170821_4_4483272\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n \n&lt;hibernate-mapping package=\"cn.itcast.c_many2many\"&gt;\n&lt;class name=\"Developer\" table=\"t_developer\"&gt;\n&lt;id name=\"d_id\"&gt;\n&lt;generator class=\"native\"&gt;&lt;/generator&gt;\n&lt;/id&gt;\n&lt;property name=\"d_name\" length=\"20\"&gt;&lt;/property&gt;\n&lt;!--\n多对多映射配置： 员工方\nname  指定映射的集合属性\ntable 集合属性对应的中间表\nkey   指定中间表的外键字段(引用当前表t_developer主键的外键字段)\nmany-to-many\ncolumn 指定外键字段对应的项目字段\nclass  集合元素的类型\n --&gt;\n&lt;set name=\"projects\" table=\"t_relation\"&gt;\n&lt;key column=\"did\"&gt;&lt;/key&gt;\n&lt;many-to-many column=\"prjId\" class=\"Project\"&gt;&lt;/many-to-many&gt;\n&lt;/set&gt;\n \n&lt;/class&gt;\n \n&lt;/hibernate-mapping&gt;\n </pre>\n <br> \n <br> \n</div> \n<div>\n <strong><br> </strong>\n</div> \n<div>\n <strong></strong>\n <pre code_snippet_id=\"2544475\" snippet_file_name=\"blog_20170821_5_8768650\" name=\"code\" class=\"java\">public class App1_save {\nprivate static SessionFactory sf;\nstatic {\nsf = new Configuration()\n.configure()\n.addClass(Project.class)   \n.addClass(Developer.class)   // 测试时候使用\n.buildSessionFactory();\n}\n \n// 1. 多对多，保存  【只能通过一方维护另外一方，不能重复维护！】\n@Test\npublic void save() {\nSession session = sf.openSession();\nsession.beginTransaction();\n/*\n * 模拟数据：\n电商系统（曹吉，王春）\nOA系统（王春，老张）\n */\n// 创建项目对象\nProject prj_ds = new Project();\nprj_ds.setPrj_name(\"电商系统\");\nProject prj_oa = new Project();\nprj_oa.setPrj_name(\"OA系统\");\n// 创建员工对象\nDeveloper dev_cj = new Developer();\ndev_cj.setD_name(\"曹吉\");\nDeveloper dev_wc = new Developer();\ndev_wc.setD_name(\"王春\");\nDeveloper dev_lz = new Developer();\ndev_lz.setD_name(\"老张\");\n// 关系 【项目方】\nprj_ds.getDevelopers().add(dev_cj);\nprj_ds.getDevelopers().add(dev_wc); // 电商系统（曹吉，王春）\nprj_oa.getDevelopers().add(dev_wc);\nprj_oa.getDevelopers().add(dev_lz); // OA系统（王春，老张）\n// 保存\n//session.save(dev_cj);\n//session.save(dev_wc);\n//session.save(dev_lz);\nsession.save(prj_ds);\nsession.save(prj_oa);   // 必须要设置级联保存\nsession.getTransaction().commit();\nsession.close();\n}\n}</pre>\n <br> \n</div> \n<br>',1,'原创','303','需求：项目与开发人员   Project   Developer   电商系统    曹吉    王春    OA系统 王春 老张 数据库     代码 /**\n * 开发人员\n *\n *\n */\npublic class Developer {\nprivate int d_id;\nprivate String d_name;\n// 开发人员，参数的多个项目\nprivate Set&lt;Project'),(5,'【Hibernate】的inverse与cascade区别？','2017-08-20','<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> Cascade:</p> \n<blockquote style=\"margin:0px 0px 1.1em; padding:15px 20px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> \n <ul style=\"\"> \n  <li style=\"\">Save-update&nbsp;<br style=\"\"> <span style=\"\">在session.save/update一个对象的时候，级联操作关联对象，关联对象或者执行save语句或者执行update语句或者什么都不执行</span></li>\n  <li style=\"\">Delete&nbsp;<br style=\"\"> <span style=\"\">在session.delete一个对象的时候，级联删除关联对象</span></li>\n  <li style=\"\">All&nbsp;<br style=\"\"> <span style=\"\">Save-update和delete的结合</span></li>\n </ul> \n</blockquote> \n<h4 id=\"2inverse\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t1\" style=\"color:rgb(12,137,207)\"></a>2.inverse</h4> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> inverse属性用于指示本方是否参与维护关系，设为true时不维护，设为false时维护。此处的关系是指关联两张表的</p> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> 外键或者关系表字段。本属性一般设置于一对多关系中的一端，并且设置为false，因为若由一端负责维护，每次更新完一端数据，都会去寻找于一端有关系的多段表中的行，并更新其外键字段。而由多端维护时，由于一端对象是多端对象的属性字段，所以，每次更新多端后提交数据，都会自动更新该字段（若有更新时），这样比较方便。</p> \n<h4 id=\"3cascade与inverse的区别-student-与-classes\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t2\" style=\"color:rgb(12,137,207)\"></a>3.Cascade与inverse的区别 student 与 classes</h4> \n<blockquote style=\"margin:0px 0px 1.1em; padding:15px 20px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> \n <ul style=\"\"> \n  <li style=\"\">cascade描述的是对象与对象之间的关系</li>\n </ul> \n</blockquote> \n<h4 id=\"cascade和外键没有关系在student表中sidnamedescription和cascade有关系但是cid和cascade没有关系\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t3\" style=\"color:rgb(12,137,207)\"></a>cascade和外键没有关系，在student表中，sid、name、description和cascade有关系，但是cid和cascade没有关系。</h4> \n<blockquote style=\"margin:0px 0px 1.1em; padding:15px 20px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> \n <ul style=\"\"> \n  <li style=\"\">inverse描述的是对象与外键之间的关系</li>\n </ul> \n</blockquote> \n<h4 id=\"inverse只和cid有关系如果维护则发出update语句更新外键的sql语句如果不维护则不管\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t4\" style=\"color:rgb(12,137,207)\"></a>inverse只和cid有关系，如果维护，则发出update语句(更新外键的sql语句)，如果不维护，则不管。</h4> \n<blockquote style=\"margin:0px 0px 1.1em; padding:15px 20px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> \n <ul style=\"\"> \n  <li style=\"\">inverse属性默认是false的，就是说关系的两端都来维护关系。当设置inverse=”true”时则不维护</li>\n </ul> \n</blockquote> \n<h4 id=\"4只有inverse没有cascade的时候\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t5\" style=\"color:rgb(12,137,207)\"></a>4.只有inverse没有cascade的时候:</h4> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <span style=\"\">对于数据中不存在的classes和student时:把student设置给classes时，仅仅保存classes而不直接保存student时只会执行insert classes的方法而对于student(即使不存在)不会insert而仅仅会update(由于在同一个事物中所以最终导致classes也不能被保存)</span></p> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <span style=\"\">当要保存的classes设置的student是数据库中存在的时候，会对其执行update方法,而如果对classes设置了cascade，则会对不存在的student设置insert:</span></p> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <span style=\"\">当给classes设置inverse=”true”时，则表示classes不维护和student的外键关系。此时当删除一个classes时,由于classes不维护与student的关系，顾不会发出update语句所以会报错。而如果classes没有设置inverse=”true”，即inverse=”false”,则说明classes维护关系。故当删除classes时会发出update student的语句，故可以删除成功.</span></p> \n<h4 id=\"5正确的设置inverse\" style=\"margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> <a target=\"_blank\" name=\"t6\" style=\"color:rgb(12,137,207)\"></a>5.正确的设置inverse</h4> \n<p style=\"margin-top:0px; margin-bottom:1.1em; padding-top:0px; padding-bottom:0px; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"> 我们说inverse设立不当会导致性能低下，其实是说inverse设立不当，会产生多余重复的SQL语句甚至致使JDBC exception的throw。这是我们在建立实体类关系时必须需要关注的地方。一般来说，inverse=true是推荐使用，双向关联中双方都设置 inverse=false的话，必会导致双方都重复更新同一个关系。但是如果双方都设立inverse=true的话，双方都不维护关系的更新，这也是不行的，<span style=\"\">好在一对多中的多端:one-to-many默认是inverse=false，避免了这种错误的产生。</span>但是多对多就没有这个默认设置了，所以很多人经常在多对多的两端都使用inverse=true，结果导致连接表的数据根本没有记录，就是因为他们双方都没有责任维护关系。所以说，<span style=\"\">双向关联中最好的设置是一端为inverse=true，一端为inverse=false。一般inverse=false会放在多的一端，</span>那么有人提问了， many－to－many两边都是多的，inverse到底放在哪儿？其实hibernate建立多对多关系也是将他们分离成两个一对多关系，中间连接一个连接表。所以通用存在一对多的关系，也可以这样说：一对多是多对多的基本组成部分。</p>',1,'原创','51','Cascade: Save-update  在session.save/update一个对象的时候，级联操作关联对象，关联对象或者执行save语句或者执行update语句或者什么都不执行 Delete  在session.delete一个对象的时候，级联删除关联对象 All  Save-update和delete的结合 2.inverse inverse属性用于指示本方是否参与维护关系，设为tru'),(6,'【Hibernate】的cascade属性','2017-08-20','<p><span style=\"color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\">删除部门时，如果部门有关联的员工且inverse属性为false，那么由于可以维护关联关系，它就会先把关联的员工的外键列设为null值，再删除自己。但是此刻希望删除部门时，就附带着把该部门下的所有员工都删掉，这时就需要引入cascade属性了。</span></p> \n<p><span style=\"font-family:&quot;microsoft yahei&quot;\"></span></p> \n<h1 id=\"级联cascade\" style=\"color:rgb(63,63,63); margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; font-family:&quot;microsoft yahei&quot;\"> <span style=\"font-size:14px\">级联（cascade）</span></h1> \n<p></p> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> 当<a target=\"_blank\" href=\"http://lib.csdn.net/base/javaee\" class=\"replace_word\" title=\"Java EE知识库\" style=\"color:rgb(223,52,52); text-decoration:none; font-weight:bold\">hibernate</a>持久化一个临时对象时，在默认情况下，它不会自动持久化所关联的其他临时对象，而是会抛出TransientObjectException。如果设定many-to-one元素的cascade属性为save-update的话，可实现自动持久化所关联的对象。如：</p> \n<pre code_snippet_id=\"2542799\" snippet_file_name=\"blog_20170820_1_3122679\" class=\"prettyprint\" name=\"code\" style=\"color: rgb(51, 51, 51); font-size: 14px; white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: &quot;Source Code Pro&quot;, monospace; padding: 5px 5px 5px 60px; line-height: 1.45; word-break: break-all; background-color: rgba(128, 128, 128, 0.0470588); border: 0px solid rgb(136, 136, 136); border-radius: 0px;\"><code class=\"hljs livecodeserver has-numbering\" style=\"display: block; padding: 0px; background: transparent; color: inherit; box-sizing: border-box; font-family: &quot;Source Code Pro&quot;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal;\">&lt;many-<span class=\"hljs-built_in\" style=\"color: rgb(102, 0, 102); box-sizing: border-box;\">to</span>-<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">one</span> name=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"customer\"</span> \n        column=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"CUSTOMER_ID\"</span> \n        class=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"..Customer\"</span>\n        cascade=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"save-update\"</span>\n        <span class=\"hljs-operator\" style=\"box-sizing: border-box;\">not</span>-<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">null</span>=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"true\"</span> /&gt;</code>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right; opacity: 0;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li>\n </ul>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">2</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">3</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">4</li>\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">5</li>\n </ul></pre> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> 级联指的是当主控方执行操作时，关联对象（被动方）是否同步执行同一操作。</p> \n<h2 id=\"级联风格\" style=\"color:rgb(63,63,63); margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; font-family:&quot;microsoft yahei&quot;\"> <span style=\"font-size:14px\"><a target=\"_blank\" name=\"t1\" style=\"color:rgb(79,161,219)\"></a></span>级联风格</h2> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> 每个Hibernate session的基本操作包括persist()、merge()、saveOrUpdate(）、delete()、lock()、refresh()、evict()、replicate()，这些操作都有对应的级联风格（cascade style）。这些级联风格（cascade style）风格分别命名为persist、merge、save-update、delete、lock、refresh、evict、replicate。</p> \n<table style=\"color:rgb(63,63,63); font-size:15px; width:708px; border-collapse:collapse; border-spacing:0px; border:1px solid rgb(238,238,238); font-family:&quot;microsoft yahei&quot;\"> \n <thead style=\"\"> \n  <tr style=\"\"> \n   <th style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> 级联风格</th> \n   <th style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> Session中的方法</th> \n  </tr> \n </thead> \n <tbody style=\"\"> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> persist</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> persist()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> merge</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> merge()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> save-update</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> save()、update()、saveOrUpdate()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> delete</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> delete()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> lock</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> lock()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> refresh</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> refresh()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> evict</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> evict()</td> \n  </tr> \n  <tr style=\"\"> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> replicate</td> \n   <td style=\"padding:8px; line-height:20px; vertical-align:top; border:1px solid rgb(238,238,238)\"> replicate()</td> \n  </tr> \n </tbody> \n</table> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> 如果你希望一个操作被顺着关联关系级联传播，你必须在映射文件中指出这一点。&nbsp;<br style=\"\"> <span style=\"\">指定级联风格</span>：</p> \n<pre code_snippet_id=\"2542799\" snippet_file_name=\"blog_20170820_2_8138405\" class=\"prettyprint\" name=\"code\" style=\"color: rgb(51, 51, 51); font-size: 14px; white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: &quot;Source Code Pro&quot;, monospace; padding: 5px 5px 5px 60px; line-height: 1.45; word-break: break-all; background-color: rgba(128, 128, 128, 0.0470588); border: 0px solid rgb(136, 136, 136); border-radius: 0px;\"><code class=\"hljs livecodeserver has-numbering\" style=\"display: block; padding: 0px; background: transparent; color: inherit; box-sizing: border-box; font-family: &quot;Source Code Pro&quot;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal;\">&lt;<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">one</span>-<span class=\"hljs-built_in\" style=\"color: rgb(102, 0, 102); box-sizing: border-box;\">to</span>-<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">one</span> name=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"person\"</span> cascade=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"persist\"</span> /&gt;</code>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right; opacity: 0;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n </ul>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n </ul></pre> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> <span style=\"\">级联风格（cascade style）是可组合的</span>：</p> \n<pre code_snippet_id=\"2542799\" snippet_file_name=\"blog_20170820_3_4616395\" class=\"prettyprint\" name=\"code\" style=\"color: rgb(51, 51, 51); font-size: 14px; white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: &quot;Source Code Pro&quot;, monospace; padding: 5px 5px 5px 60px; line-height: 1.45; word-break: break-all; background-color: rgba(128, 128, 128, 0.0470588); border: 0px solid rgb(136, 136, 136); border-radius: 0px;\"><code class=\"hljs livecodeserver has-numbering\" style=\"display: block; padding: 0px; background: transparent; color: inherit; box-sizing: border-box; font-family: &quot;Source Code Pro&quot;, monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal;\">&lt;<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">one</span>-<span class=\"hljs-built_in\" style=\"color: rgb(102, 0, 102); box-sizing: border-box;\">to</span>-<span class=\"hljs-constant\" style=\"box-sizing: border-box;\">one</span> name=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"person\"</span> cascade=<span class=\"hljs-string\" style=\"color: rgb(0, 136, 0); box-sizing: border-box;\">\"persist,delete\"</span> /&gt;</code>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right; opacity: 0;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n </ul>\n <ul class=\"pre-numbering\" style=\"list-style: none; box-sizing: border-box; position: absolute; width: 50px; background-color: rgb(238, 238, 238); top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right: 1px solid rgb(221, 221, 221); text-align: right;\">\n  <li style=\"box-sizing: border-box; padding: 0px 5px;\">1</li>\n </ul></pre> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> 你可以使用cascade=”all”来指定全部操作都顺着关联关系级联（cascaded）。默认值是cascade=”none”，即任何操作都不会被级联（cascaded）。&nbsp;<br style=\"\"> 在对象/关系映射文件中，用于映射持久化类之间关联关系的元素，如<code style=\"font-family:&quot;Source Code Pro&quot;,monospace; padding:2px 4px; font-size:13.5px; white-space:nowrap\">&lt;set&gt;</code>、<code style=\"font-family:&quot;Source Code Pro&quot;,monospace; padding:2px 4px; font-size:13.5px; white-space:nowrap\">&lt;many-to-one&gt;</code>和<code style=\"font-family:&quot;Source Code Pro&quot;,monospace; padding:2px 4px; font-size:13.5px; white-space:nowrap\">&lt;one-to-one&gt;</code>都有一个cascade属性。&nbsp;</p> \n<p style=\"color:rgb(63,63,63); font-size:15px; margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"> <img src=\"http://img.blog.csdn.net/20161008194700362\" alt=\"这里写图片描述\" title=\"\" style=\"border:none; max-width:100%; color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"><br> </p> \n<p style=\"margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"></p> \n<h2 id=\"总结\" style=\"color:rgb(63,63,63); margin:0.8em 0px; padding:0px; font-weight:100; line-height:1.3em; font-family:&quot;microsoft yahei&quot;\"> <span style=\"font-size:14px\">总结</span></h2> \n<p></p> \n<p style=\"margin-top:0px; margin-bottom:1.1em; font-family:&quot;microsoft yahei&quot;\"><span style=\"color:rgb(63,63,63); font-size:15px\">一般是多对一和多对多的时候不使用级联，一对一和一对多可以使用级联，这两种情况使用级联比较多，总结来说，这个对象归你控制，你就能够级联，它不归你一个人所有，那你就不要级联。&nbsp;</span><br style=\"\"> <span style=\"font-size:18px; color:#ff0000\">还有一点要注意，inverse属性和cascade属性毛关系都没有。</span></p> \n<p><span style=\"color:rgb(63,63,63); font-family:&quot;microsoft yahei&quot;; font-size:15px\"><br> </span></p>',1,'原创','60','删除部门时，如果部门有关联的员工且inverse属性为false，那么由于可以维护关联关系，它就会先把关联的员工的外键列设为null值，再删除自己。但是此刻希望删除部门时，就附带着把该部门下的所有员工都删掉，这时就需要引入cascade属性了。 级联（cascade） 当hibernate持久化一个临时对象时，在默认情况下，它不会自动持久化所关联的其他临时对象，而是会抛出TransientObje'),(7,'【Hibernate】的Inverse属性','2017-08-20','<h2 align=\"justify\"><br> </h2> \n<p align=\"justify\">Inverse<span style=\"font-family:宋体\">属性</span><span style=\"font-family:宋体\">，是在维护关联关系的时候起作用的。</span></p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">表示控制权是否转移。</span>(<span style=\"font-family:宋体\">在一的一方起作用</span><span style=\"font-family:Calibri\">)</span></p> \n<p align=\"justify\">&nbsp;</p> \n<p align=\"justify\">Inverse , <span style=\"font-family:宋体\">控制反转。</span>默认为false<span style=\"font-family:宋体\">不反转</span></p> \n<p align=\"justify\">Inverse = false &nbsp;<span style=\"font-family:宋体\">不反转； &nbsp;&nbsp;当前方有控制权</span></p> \n<p align=\"justify\">True &nbsp;<span style=\"font-family:宋体\">控制反转； 当前方没有控制权</span></p> \n<p align=\"justify\">&nbsp;</p> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:宋体\">维护关联关系中，是否设置</span>inverse<span style=\"font-family:宋体\">属性：</span></span></p> \n<p>1. <span style=\"font-family:宋体\">保存数据 </span></p> \n<p align=\"justify\"><strong><span style=\"color:rgb(255,0,0)\">有影响。</span></strong></p> \n<p align=\"justify\">&nbsp;&nbsp;<span style=\"color:rgb(255,0,0)\">&nbsp;<span style=\"font-family:宋体\">如果设置控制反转</span>,<span style=\"font-family:宋体\">即</span><span style=\"font-family:Calibri\">inverse=true,</span><span style=\"font-family:宋体\">然后通过部门方维护关联关系。在保存部门的时候，同时保存员工， 数据会保存，但关联关系不会维护。即外键字段为</span><span style=\"font-family:Calibri\">NULL</span></span></p> \n<p>2. <span style=\"font-family:宋体\">获取数据</span></p> \n<p align=\"justify\"><strong><span style=\"color:rgb(255,0,0)\">无。</span></strong></p> \n<p>3. <span style=\"font-family:宋体\">解除关联关系？</span></p> \n<p align=\"justify\"><strong><span style=\"color:rgb(255,0,0)\">有影响。</span></strong></p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\">inverse=false<span style=\"font-family:宋体\">， &nbsp;可以解除关联</span></span></p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\">inverse=true<span style=\"font-family:宋体\">， &nbsp;当前方</span><span style=\"font-family:Calibri\">(</span><span style=\"font-family:宋体\">部门</span><span style=\"font-family:Calibri\">)</span><span style=\"font-family:宋体\">没有控制权，不能解除关联关系</span></span></p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\">(<span style=\"font-family:宋体\">不会生成</span><span style=\"font-family:Calibri\">update</span><span style=\"font-family:宋体\">语句</span><span style=\"font-family:Calibri\">,</span><span style=\"font-family:宋体\">也不会报错</span><span style=\"font-family:Calibri\">)</span></span></p> \n<p>4. <span style=\"font-family:宋体\">删除数据对关联关系的影响？</span></p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\">有影响。</span></p> \n<p align=\"justify\">inverse=false, <span style=\"font-family:宋体\">有控制权， 可以删除。先清空外键引用，再删除数据。</span></p> \n<p align=\"justify\">inverse=true, &nbsp;<span style=\"font-family:宋体\">没有控制权</span><span style=\"font-family:Calibri\">:</span><span style=\"font-family:宋体\">如果删除的记录有被外键引用，会报错，违反主外键引用约束！ &nbsp;如果删除的记录没有被引用，可以直接删除。</span></p> \n<p align=\"justify\">&nbsp;</p>',1,'原创','47','Inverse属性，是在维护关联关系的时候起作用的。        表示控制权是否转移。(在一的一方起作用)   Inverse , 控制反转。默认为false不反转 Inverse = false  不反转；   当前方有控制权 True  控制反转； 当前方没有控制权   维护关联关系中，是否设置inverse属性： 1. 保存数据 有影响。    如果设置控制反转,即inverse=true'),(8,'【Hibernate】的一对多与多对一映射','2017-08-20','<p><span style=\"font-family:KaiTi_GB2312\">1、代码&amp;&amp;图示</span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><img src=\"http://img.blog.csdn.net/20170820155832996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\">Dept.java</span></p> \n<p></p> \n<pre code_snippet_id=\"2542695\" snippet_file_name=\"blog_20170820_1_8892207\" name=\"code\" class=\"java\"><span style=\"font-family:KaiTi_GB2312;\">public class Dept {\n\n	private int deptId;\n	private String deptName;\n	// 【一对多】 部门对应的多个员工\n	private Set&lt;Employee&gt; emps = new HashSet&lt;Employee&gt;();\n       ...\n}</span></pre> \n<p></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<span style=\"font-family:KaiTi_GB2312\">Emploee.java<br> </span>\n<pre code_snippet_id=\"2542695\" snippet_file_name=\"blog_20170820_2_6100545\" name=\"code\" class=\"java\"><span style=\"font-family:KaiTi_GB2312;\">public class Employee {\n\n	private int empId;\n	private String empName;\n	private double salary;\n	// 【多对一】员工与部门\n	private Dept dept;\n        ...\n}</span></pre> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\">Dept.hbm.xml</span></p> \n<p></p> \n<pre code_snippet_id=\"2542695\" snippet_file_name=\"blog_20170820_3_8990483\" name=\"code\" class=\"html\"><span style=\"font-family:KaiTi_GB2312;\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n	\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n	\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n\n&lt;hibernate-mapping package=\"cn.lfsenior.b_one2Many\"&gt;\n	\n	&lt;class name=\"Dept\" table=\"t_dept\"&gt;\n		&lt;id name=\"deptId\"&gt;\n			&lt;generator class=\"native\"&gt;&lt;/generator&gt;\n		&lt;/id&gt;	\n		&lt;property name=\"deptName\" length=\"20\"&gt;&lt;/property&gt;\n		\n		&lt;!-- \n			一对多关联映射配置  （通过部门管理到员工）\n			Dept 映射关键点：\n			1.  指定 映射的集合属性： \"emps\"\n			2.  集合属性对应的集合表： \"t_employee\"\n			3.  集合表的外键字段   \"t_employee. dept_id\"\n			4.  集合元素的类型\n			\n		 --&gt;\n		 &lt;set name=\"emps\"&gt;   &lt;!-- table=\"t_employee\" --&gt;\n		 	 &lt;key column=\"dept_id\"&gt;&lt;/key&gt;\n		 	 &lt;one-to-many class=\"Employee\"/&gt;\n		 &lt;/set&gt;\n		 \n		 \n	&lt;/class&gt;\n	\n\n&lt;/hibernate-mapping&gt;</span></pre> \n<p></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<span style=\"font-family:KaiTi_GB2312\">Employee.hbm.xml<br> </span>\n<pre code_snippet_id=\"2542695\" snippet_file_name=\"blog_20170820_4_2196067\" name=\"code\" class=\"html\"><span style=\"font-family:KaiTi_GB2312;\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n	\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n	\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n\n&lt;hibernate-mapping package=\"cn.lfsenior.b_one2Many\"&gt;\n	\n	&lt;class name=\"Employee\" table=\"t_employee\"&gt;\n		&lt;id name=\"empId\"&gt;\n			&lt;generator class=\"native\"&gt;&lt;/generator&gt;\n		&lt;/id&gt;	\n		&lt;property name=\"empName\" length=\"20\"&gt;&lt;/property&gt;\n		&lt;property name=\"salary\" type=\"double\"&gt;&lt;/property&gt;\n		\n		&lt;!-- \n			多对一映射配置\n			Employee 映射关键点：\n			1.  映射的部门属性  ：  dept\n			2.  映射的部门属性，对应的外键字段: dept_id\n			3.  部门的类型\n		 --&gt;\n		 &lt;many-to-one name=\"dept\" column=\"dept_id\" class=\"Dept\"&gt;&lt;/many-to-one&gt;\n		 \n	&lt;/class&gt;\n	\n\n&lt;/hibernate-mapping&gt;</span></pre>\n<span style=\"font-family:KaiTi_GB2312\"><br> <br> </span> \n<p></p> \n<pre code_snippet_id=\"2542695\" snippet_file_name=\"blog_20170820_5_7037853\" name=\"code\" class=\"java\"><span style=\"font-family:KaiTi_GB2312;\">public class App {\n	\n	private static SessionFactory sf;\n	static {\n		sf = new Configuration()\n			.configure()\n			.addClass(Dept.class)   \n			.addClass(Employee.class)   // 测试时候使用\n			.buildSessionFactory();\n	}\n\n	// 保存， 部门方 【一的一方法操作】\n	@Test\n	public void save() {\n		\n		Session session = sf.openSession();\n		session.beginTransaction();\n		\n		// 部门对象\n		Dept dept = new Dept();\n		dept.setDeptName(\"应用开发部\");\n		// 员工对象\n		Employee emp_zs = new Employee();\n		emp_zs.setEmpName(\"张三\");\n		Employee emp_ls = new Employee();\n		emp_ls.setEmpName(\"李四\");\n		// 关系\n		dept.getEmps().add(emp_zs);\n		dept.getEmps().add(emp_ls);\n\n		// 保存\n		session.save(emp_zs);\n		session.save(emp_ls);\n		session.save(dept); // 保存部门，部门下所有的员工  \n		\n		session.getTransaction().commit();\n		session.close();\n		/*\n		 *  结果\n		 *  Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?)\n			Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?)\n			Hibernate: insert into t_dept (deptName) values (?)\n			Hibernate: update t_employee set deptId=? where empId=?    维护员工引用的部门的id\n			Hibernate: update t_employee set deptId=? where empId=?\n		 */\n	}\n	// 【推荐】 保存， 部员方 【多的一方法操作】\n	@Test\n	public void save2() {\n		\n		Session session = sf.openSession();\n		session.beginTransaction();\n		\n		// 部门对象\n		Dept dept = new Dept();\n		dept.setDeptName(\"综合部\");\n		// 员工对象\n		Employee emp_zs = new Employee();\n		emp_zs.setEmpName(\"张三\");\n		Employee emp_ls = new Employee();\n		emp_ls.setEmpName(\"李四\");\n		// 关系\n		emp_zs.setDept(dept);\n		emp_ls.setDept(dept);\n		\n		\n		// 保存\n		session.save(dept); // 先保存一的方法\n		session.save(emp_zs);\n		session.save(emp_ls);// 再保存多的一方，关系回自动维护(映射配置完)\n		\n		session.getTransaction().commit();\n		session.close();\n		/*\n		 *  结果\n		 *  Hibernate: insert into t_dept (deptName) values (?)\n			Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?)\n			Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?)\n			少生成2条update  sql\n		 */\n	}\n	\n}</span></pre>\n<span style=\"font-family:KaiTi_GB2312\"><br> <br> </span> \n<p></p> \n<span style=\"font-family:KaiTi_GB2312\"><br> </span> \n<h3><span style=\"font-family:KaiTi_GB2312\">总结：</span></h3> \n<p><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;在一对多与多对一的关联关系中，保存数据最好的<strong><span style=\"color:rgb(255,0,0)\">通过多的一方来维护关系</span></strong>，这样可以减少update语句的生成，从而提高hibernate的执行效率！</span></p> \n<p></p> \n<p><span style=\"font-family:KaiTi_GB2312\">配置一对多与多对一，这种叫“双向关联”</span></p> \n<p><span style=\"font-family:KaiTi_GB2312\">只配置一对多， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;叫“单项一对多”</span></p> \n<p><span style=\"font-family:KaiTi_GB2312\">只配置多对一， &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;叫“单项多对一”</span></p> \n<p><span style=\"font-family:KaiTi_GB2312\">&nbsp;</span></p> \n<h3><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:KaiTi_GB2312\">注意：</span></span></h3> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:KaiTi_GB2312\">配置了哪一方，哪一方才有维护关联关系的权限！</span></span></p> \n<span style=\"font-family:KaiTi_GB2312\"><br> </span> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><span style=\"font-family:KaiTi_GB2312\"><br> </span></p> \n<p><br> </p>',1,'原创','62','1、代码&&图示 Dept.java public class Dept {\n\n	private int deptId;\n	private String deptName;\n	// 【一对多】 部门对应的多个员工\n	private Set&lt;Employee/&gt emps = new HashSet&lt;Employee/&gt();\n       ...\n} Emploee.java public class'),(9,'【Hibernate】简单集合映射','2017-08-20','<pre code_snippet_id=\"2542377\" snippet_file_name=\"blog_20170820_1_4774505\" name=\"code\" class=\"java\">// javabean设计\npublic class User {\n\n	private int userId;\n	private String userName;\n	// 一个用户，对应的多个地址\n	private Set&lt;String&gt; address;\n	private List&lt;String&gt; addressList = new ArrayList&lt;String&gt;(); \n	//private String[] addressArray; // 映射方式和list一样     &lt;array name=\"\"&gt;&lt;/array&gt;\n	private Map&lt;String,String&gt; addressMap = new HashMap&lt;String, String&gt;();\n	\n}</pre> \n<p><br> </p> \n<p></p> \n<pre code_snippet_id=\"2542377\" snippet_file_name=\"blog_20170820_2_9266844\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n	\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n	\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n\n&lt;hibernate-mapping package=\"cn.lfsenior.a_collection\"&gt;\n	\n	&lt;class name=\"User\" table=\"t_user\"&gt;\n		&lt;id name=\"userId\" column=\"id\"&gt;\n			&lt;generator class=\"native\"&gt;&lt;/generator&gt;\n		&lt;/id&gt;	\n		&lt;property name=\"userName\"&gt;&lt;/property&gt;\n		\n		&lt;!-- \n			set集合属性的映射\n				name 指定要映射的set集合的属性\n				table 集合属性要映射到的表\n				key  指定集合表(t_address)的外键字段\n				element 指定集合表的其他字段\n					type 元素类型，一定要指定\n		 --&gt;\n		 &lt;set name=\"address\" table=\"t_address\"&gt;\n		 	&lt;key column=\"uid\"&gt;&lt;/key&gt;\n		 	&lt;element column=\"address\" type=\"string\"&gt;&lt;/element&gt;\n		 &lt;/set&gt;\n		 \n		 &lt;!-- \n		 	list集合映射\n		 		list-index  指定的是排序列的名称 (因为要保证list集合的有序)\n		  --&gt;\n		  &lt;list name=\"addressList\" table=\"t_addressList\"&gt;\n		  	  &lt;key column=\"uid\"&gt;&lt;/key&gt;\n		  	  &lt;list-index column=\"idx\"&gt;&lt;/list-index&gt;\n		  	  &lt;element column=\"address\" type=\"string\"&gt;&lt;/element&gt;\n		  &lt;/list&gt;\n		  \n		  &lt;!-- \n		  	map集合的映射\n		  		key  指定外键字段\n		  		map-key 指定map的key \n		  		element  指定map的value\n		   --&gt;\n		  &lt;map name=\"addressMap\" table=\"t_addressMap\"&gt;\n		  	&lt;key column=\"uid\"&gt;&lt;/key&gt;\n		  	&lt;map-key column=\"shortName\" type=\"string\" &gt;&lt;/map-key&gt;\n		  	&lt;element column=\"address\" type=\"string\" &gt;&lt;/element&gt;\n		  &lt;/map&gt;\n		  \n		 \n	&lt;/class&gt;\n	\n\n&lt;/hibernate-mapping&gt;</pre>\n<br> \n<p></p> \n<p><br> </p> \n<p><br> </p> \n<p></p> \n<pre code_snippet_id=\"2542377\" snippet_file_name=\"blog_20170820_3_4108631\" name=\"code\" class=\"java\">// 保存set\n	@Test\n	public void testSaveSet() throws Exception {\n		Session session = sf.openSession();\n		session.beginTransaction();\n		\n		//-- 保存\n		Set&lt;String&gt; addressSet = new HashSet&lt;String&gt;();\n		addressSet.add(\"广州\");\n		addressSet.add(\"深圳\");\n		// 用户对象\n		User user = new User();\n		user.setUserName(\"Jack\");\n		user.setAddress(addressSet);\n		\n		// 保存\n		session.save(user);\n		\n		session.getTransaction().commit();\n		session.close();\n	}\n	\n	// 保存list/map\n	@Test\n	public void testSaveList() throws Exception {\n		Session session = sf.openSession();\n		session.beginTransaction();\n		User user = new User();\n		user.setUserName(\"Tom\");\n//		// 用户对象  --  list\n//		user.getAddressList().add(\"广州\");\n//		user.getAddressList().add(\"深圳\");\n//		// 保存\n//		session.save(user);\n		\n		// 用户对象  --  Map\n		user.getAddressMap().put(\"A0001\", \"广州\");\n		user.getAddressMap().put(\"A0002\", \"深圳\");\n		\n		// 保存\n		session.save(user);\n		\n		session.getTransaction().commit();\n		session.close();\n	}\n\n\n	// 获取\n	@Test\n	public void testGet() throws Exception {\n		Session session = sf.openSession();\n		session.beginTransaction();\n		\n		// 获取\n		User user = (User) session.get(User.class, 3); // 及时加载\n		System.out.println(user.getUserId());\n		System.out.println(user.getUserName());\n		\n		// 当查询用户，同时可以获取用户关联的list集合的数据 (因为有正确映射)\n		// 当使用到集合数据的使用，才向数据库发送执行的sql语句  (懒加载)\n		System.out.println(user.getAddressList());\n		\n		session.getTransaction().commit();\n		session.close();\n	}\n</pre>\n<br> \n<br> \n<p></p>',1,'原创','59','// javabean设计\npublic class User {\n\n	private int userId;\n	private String userName;\n	// 一个用户，对应的多个地址\n	private Set&lt;String/&gt address;\n	private List&lt;String/&gt addressList = new ArrayList&lt;String/&gt(); \n	//privat'),(10,'【Hibernate】中Query对象在获取表的所有的数据的时候，使用list()和 iterator()有什么区别？','2017-08-20','<h2 align=\"justify\"><strong><span style=\"font-family:KaiTi_GB2312\">Hibernate中Query对象在获取表的所有的数据的时候，使用list()和 iterator()有什么区别？</span></strong></h2> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;# 编写代码的方式不同 list()和iterator()</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;# 底层发送的SQL语句不同</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list()直接一次性获取到所有持久化类的对象</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator()先获取的是所有的数据的id值。当真正的遍历使用数据的</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时候再发送select语句。因此该方法一定要处于session会话中。</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;# list发送的查询语句只有1条。Iterator发送多条查询语句，因此</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator的效率低下。懒汉式(iterator) &nbsp;&nbsp;饿汉式(list)</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;</span></p> \n<h2 align=\"justify\"><strong><span style=\"font-family:KaiTi_GB2312\">list和iterator什么时候使用？</span></strong></h2> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;list()如果表中有少量条数据</span></p> \n<p align=\"justify\"><span style=\"font-family:KaiTi_GB2312\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator()如果表中有N W条数据</span></p>',1,'原创','90','Hibernate中Query对象在获取表的所有的数据的时候，使用list()和 iterator()有什么区别？     # 编写代码的方式不同 list()和iterator()     # 底层发送的SQL语句不同         list()直接一次性获取到所有持久化类的对象         iterator()先获取的是所有的数据的id值。当真正的遍历使用数据的         时候再发'),(11,'【Hibernate】中session的get()和load()有什么区别?','2017-08-20','<h2 align=\"justify\"><strong>Hibernate中session的get()和load()有什么区别?</strong></h2> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;# get()如果没有找到持久化类返回null，有可能导致空指针异常。</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;# load()如果没有找到持久化类直接抛出异常。</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;# get()是直接加载数据，load()是延迟加载，当使用被加载数据的时候才发送SQL。</p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">简而言之：</span>Hibernate对于load()认为数据库一定存在，因此可以放心的使用代理进行延迟加载，如果使用中发现了问题，那么只能抛出异常。而对于get方法一定要获取真实的数据，否则返回null。</span></p> \n<p align=\"justify\">DataType dataType1 = (DataType) session.load(DataType.class, new Long(1));</p> \n<p align=\"justify\">DataType dataType2 = (DataType) session.load(DataType.class, new Long(1));</p> \n<p align=\"justify\">System.out.println(dataType1); &nbsp;&nbsp;// 延迟加载，需要使用才发送SQL语句</p> \n<p align=\"justify\">System.out.println(dataType2); &nbsp;&nbsp;// 从一级缓存中获取持久化对象</p> \n<p align=\"justify\">System.out.println(dataType1 == dataType2);</p> \n<p align=\"justify\">session.getTransaction().commit();</p>',1,'原创','52','Hibernate中session的get()和load()有什么区别?     # get()如果没有找到持久化类返回null，有可能导致空指针异常。     # load()如果没有找到持久化类直接抛出异常。     # get()是直接加载数据，load()是延迟加载，当使用被加载数据的时候才发送SQL。 简而言之：Hibernate对于load()认为数据库一定存在，因此可以放心的使用代理'),(12,'【hibernate】查询方式与区别','2017-08-19','<p><span style=\"color:rgb(255,0,0)\">主键查询：</span></p> \n<p><span style=\"color:rgb(255,0,0)\">session.get(Employee.class, 1);</span><span style=\"color:rgb(255,0,0)\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">主键查询</span></span></p> \n<p><span style=\"color:rgb(255,0,0)\">session.</span><span style=\"color:rgb(255,0,0)\">load</span><span style=\"color:rgb(255,0,0)\">(Employee.class, 1);</span><span style=\"color:rgb(255,0,0)\">&nbsp;&nbsp;&nbsp;<span style=\"font-family:宋体\">主键查询</span> (<span style=\"font-family:宋体\">支持懒加载</span><span style=\"font-family:Calibri\">)</span></span></p> \n<p>&nbsp;</p> \n<p>HQL<span style=\"font-family:宋体\">查询：</span></p> \n<p>HQL<span style=\"font-family:宋体\">查询与</span><span style=\"font-family:Calibri\">SQL</span><span style=\"font-family:宋体\">查询区别：</span></p> \n<p><strong>SQL</strong>: (<span style=\"font-family:宋体\">结构化查询语句</span><span style=\"font-family:Calibri\">)</span><span style=\"font-family:宋体\">查询的是表以及字段</span><span style=\"font-family:Calibri\">; &nbsp;</span><span style=\"font-family:宋体\">不区分大小写。</span></p> \n<p><strong>HQL</strong>: hibernate &nbsp;query &nbsp;language <span style=\"font-family:宋体\"> 即</span><span style=\"font-family:Calibri\">hibernate</span><span style=\"font-family:宋体\">提供的面向对象的查询语言</span></p> \n<p>查询的是对象以及对象的属性。</p> \n<p>区分大小写。</p> \n<p>&nbsp;</p> \n<p>Criteria<span style=\"font-family:宋体\">查询：</span></p> \n<p>&nbsp;<span style=\"font-family:宋体\">完全面向对象的查询。</span></p> \n<p><span style=\"font-family:宋体\">本地</span>SQL<span style=\"font-family:宋体\">查询：</span></p> \n<p><span style=\"font-family:宋体\">复杂的查询，就要使用原生态的</span>sql<span style=\"font-family:宋体\">查询，也可以，就是本地</span><span style=\"font-family:Calibri\">sql</span><span style=\"font-family:宋体\">查询的支持！</span></p> \n<p>(<span style=\"font-family:宋体\">缺点： 不能跨数据库平台！</span><span style=\"font-family:Calibri\">)</span></p>',1,'原创','2850','主键查询： session.get(Employee.class, 1);    主键查询 session.load(Employee.class, 1);   主键查询 (支持懒加载)   HQL查询： HQL查询与SQL查询区别： SQL: (结构化查询语句)查询的是表以及字段;  不区分大小写。 HQL: hibernate  query  language 即hibernate提供的面向对'),(13,'【Hibernate】的运行过程如下','2017-05-19','<h2 align=\"justify\"><strong>Hibernate的运行过程如下：</strong></h2> \n<p align=\"justify\">&nbsp;</p> \n<p align=\"justify\">1、应用程序先调用Configuration类,该类读取Hibernate配置文件及映射文件中的信息，</p> \n<p align=\"justify\">2、并用这些信息生成一个SessionFactory对象，</p> \n<p align=\"justify\">3、然后从SessionFactory对象生成一个Session对象，</p> \n<p align=\"justify\">4、并用Session对象生成Transaction对象；</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;A、可通过Session对象的get(),load(),save(),update(),delete()</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:楷体\">和</span>saveOrUpdate()等方法对PO进行加载、保存、更新、删除、</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:楷体\">等操作；</span></p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;B、在查询的情况下，可通过Session对象生成一个Query对象，然后</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:楷体\">利用</span>Query对象执行查询操作；如果没有异常，Transaction对象将</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:楷体\">提交这些操作到数据库中。</span></p> \n<p align=\"justify\">&nbsp;</p> \n<p align=\"justify\">&nbsp;<img src=\"http://img.blog.csdn.net/20170519114031272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p align=\"justify\">&nbsp;</p> \n<h2 align=\"justify\"><strong>Hibernate的运行过程图示：</strong></h2> \n<p align=\"justify\">&nbsp;<img src=\"http://img.blog.csdn.net/20170519114040101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p align=\"justify\">&nbsp;</p> \n<p align=\"justify\">&nbsp;</p>',1,'原创','3358','Hibernate的运行过程如下：   1、应用程序先调用Configuration类,该类读取Hibernate配置文件及映射文件中的信息， 2、并用这些信息生成一个SessionFactory对象， 3、然后从SessionFactory对象生成一个Session对象， 4、并用Session对象生成Transaction对象；     A、可通过Session对象的get(),load(),'),(14,'【Hibernate】主键生成策略图示','2017-05-19','<h2><strong>Hibernate主键生成策略图示</strong></h2> \n<table> \n <tbody> \n  <tr> \n   <td valign=\"top\"> <p>identity</p> </td> \n   <td valign=\"top\"> <p>采用数据库生成的主键，用于为<span style=\"font-family:Arial\">long</span><span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">short</span><span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">int</span><span style=\"font-family:宋体\">类型生成唯一标识</span><span style=\"font-family:Arial\">,&nbsp;Oracle&nbsp;</span><span style=\"font-family:宋体\">不支持自增字段</span><span style=\"font-family:Arial\">.</span></p> </td> \n   <td valign=\"top\"> <p>&lt;id&nbsp;name=\"id\"&nbsp;column=\"id\"&nbsp;type=\"long\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=\"identity\"&nbsp;/&gt;</p> <p>&lt;/id&gt;</p> </td> \n  </tr> \n  <tr> \n   <td valign=\"top\"> <p>sequence</p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n   <td valign=\"top\"> <p>DB2<span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">Oracle</span><span style=\"font-family:宋体\">均支持的序列，用于为</span><span style=\"font-family:Arial\">long</span><span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">short</span><span style=\"font-family:宋体\">或</span><span style=\"font-family:Arial\">int</span><span style=\"font-family:宋体\">生成唯一标识。</span></p> <p>需要<span style=\"font-family:Arial\">oracle</span><span style=\"font-family:宋体\">创建</span><span style=\"font-family:Arial\">sequence</span><span style=\"font-family:宋体\">。</span></p> </td> \n   <td valign=\"top\"> <p>&lt;id&nbsp;name=\"id\"&nbsp;column=\"id\"&nbsp;type=\"long\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=\"sequence\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param&nbsp;name=\"sequence\"&gt;seq_name&lt;/param&gt;</p> <p>&nbsp;&nbsp;&nbsp;&lt;/generator&gt;</p> <p>&lt;/id&gt;</p> </td> \n  </tr> \n  <tr> \n   <td valign=\"top\"> <p>native</p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n   <td valign=\"top\"> <p>根据底层数据库的能力，从<span style=\"font-family:Arial\">identity</span><span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">sequence</span><span style=\"font-family:宋体\">、</span><span style=\"font-family:Arial\">hilo</span><span style=\"font-family:宋体\">中选择一个，灵活性更强。</span></p> </td> \n   <td valign=\"top\"> <p>&lt;id&nbsp;name=\"id\"&nbsp;column=\"id\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=\"native\"&nbsp;/&gt;</p> <p>&lt;/id&gt;</p> </td> \n  </tr> \n  <tr> \n   <td valign=\"top\"> <p>increment</p> </td> \n   <td valign=\"top\"> <p>个是由<span style=\"font-family:Arial\">Hibernate</span><span style=\"font-family:宋体\">在内存中生成主键，每次增量为</span><span style=\"font-family:Arial\">1</span><span style=\"font-family:宋体\">，不依赖于底层的数据库，因此所有的数据库都可以使用</span></p> </td> \n   <td valign=\"top\"> <p>&lt;id&nbsp;name=\"id\"&nbsp;column=\"id\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=\"increment\"&nbsp;/&gt;</p> <p>&lt;/id&gt;</p> </td> \n  </tr> \n  <tr> \n   <td valign=\"top\"> <p>uuid.hex</p> <p>&nbsp;</p> </td> \n   <td valign=\"top\"> <p>使用一个<span style=\"font-family:Arial\">128-bit</span><span style=\"font-family:宋体\">的</span><span style=\"font-family:Arial\">UUID</span><span style=\"font-family:宋体\">算法生成字符串类型的标识符</span></p> </td> \n   <td valign=\"top\"> <p>&lt;id&nbsp;name=\"id\"&nbsp;column=\"id\"&gt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=\"uuid.hex\"&nbsp;/&gt;</p> <p>&lt;/id&gt;</p> </td> \n  </tr> \n  <tr> \n   <td valign=\"top\"> <p>uuid.string</p> </td> \n   <td valign=\"top\"> <p>hibernate<span style=\"font-family:宋体\">会算出一个</span><span style=\"font-family:Arial\">16</span><span style=\"font-family:宋体\">位的值插入</span></p> </td> \n   <td valign=\"top\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<br>',1,'原创','3152','Hibernate主键生成策略图示 identity 采用数据库生成的主键，用于为long、short、int类型生成唯一标识, Oracle 不支持自增字段. &lt;id name=\"id\" column=\"id\" type=\"long\"/&gt     &lt;generator class=\"identity\" //&gt &lt;/id/&gt sequence     DB2、Oracle均支持的序列，用于为long、s'),(15,'【Hibernate】映射配置','2017-05-19','<h2><strong>一、映射配置</strong></h2> \n<h3>1. 普通字段类型</h3> \n<h3>2. 主键映射</h3> \n<p>单列主键映射</p> \n<p>多列作为主键映射</p> \n<p>&nbsp;</p> \n<p><span style=\"font-family:楷体\">主键生成策略，查看</span>api： &nbsp;&nbsp;5.1.2.2.1. Various additional generators</p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<h3>3. 数据库：</h3> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">一个表能否有多个主键？</span> &nbsp;&nbsp;<span style=\"font-family:楷体\">不能。</span></span></p> \n<p><span style=\"font-family:楷体\">为什么要设置主键？</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family:楷体\">数据库存储的数据都是有效的，必须保持唯一。</span></p> \n<p>&nbsp;</p> \n<p><span style=\"color:rgb(255,0,0)\">(为什么把id作为主键？)</span></p> \n<p><span style=\"font-family:楷体\">因为表中通常找不到合适的列作为唯一列即主键，所以为了方法用</span>id列，因为id是数据库系统维护可以保证唯一，所以就把这列作为主键!</p> \n<p>&nbsp;</p> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">联合</span>/复合主键</span></p> \n<p><span style=\"font-family:楷体\">如果找不到合适的列作为主键，出来用</span>id列以外，我们一般用联合主键，即多列的值作为一个主键，从而确保记录的唯一性。</p> \n<p>&nbsp;</p> \n<h2><strong>二、单列映射配置</strong></h2> \n<p></p> \n<pre code_snippet_id=\"2405133\" snippet_file_name=\"blog_20170519_1_3808375\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n \n \n&lt;!-- 映射文件: 映射一个实体类对象；  描述一个对象最终实现可以直接保存对象数据到数据库中。  --&gt;\n&lt;!--\npackage: 要映射的对象所在的包(可选,如果不指定,此文件所有的类都要指定全路径)\nauto-import 默认为true， 在写hql的时候自动导入包名\n如果指定为false, 再写hql的时候必须要写上类的全名；\n  如：session.createQuery(\"from cn.itcast.c_hbm_config.Employee\").list();\n --&gt;\n&lt;hibernate-mapping package=\"cn.lfsenior.c_hbm_config\" auto-import=\"true\"&gt;\n&lt;!--\nclass 映射某一个对象的(一般情况，一个对象写一个映射文件，即一个class节点)\nname 指定要映射的对象的类型\ntable 指定对象对应的表；\n  如果没有指定表名，默认与对象名称一样\n --&gt;\n&lt;class name=\"Employee\" table=\"employee\"&gt;\n&lt;!-- 主键 ，映射--&gt;\n&lt;id name=\"empId\" column=\"id\"&gt;\n&lt;!--\n主键的生成策略\nidentity  自增长(mysql,db2)\nsequence  自增长(序列)， oracle中自增长是以序列方法实现\nnative  自增长【会根据底层数据库自增长的方式选择identity或sequence】\n如果是mysql数据库, 采用的自增长方式是identity\n如果是oracle数据库， 使用sequence序列的方式实现自增长\nincrement  自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)\nassigned  指定主键生成策略为手动指定主键的值\nuuid      指定uuid随机生成的唯一的值\nforeign   (外键的方式， one-to-one讲)\n --&gt;\n&lt;generator class=\"uuid\"/&gt;\n&lt;/id&gt;\n&lt;!--\n普通字段映射\nproperty\nname  指定对象的属性名称\ncolumn 指定对象属性对应的表的字段名称，如果不写默认与对象属性一致。\nlength 指定字符的长度, 默认为255\ntype   指定映射表的字段的类型，如果不指定会匹配属性的类型\njava类型：     必须写全名\nhibernate类型：  直接写类型，都是小写\n--&gt;\n&lt;property name=\"empName\" column=\"empName\" type=\"java.lang.String\" length=\"20\"&gt;&lt;/property&gt;\n&lt;property name=\"workDate\" type=\"java.util.Date\"&gt;&lt;/property&gt;\n&lt;!-- 如果列名称为数据库关键字，需要用反引号或改列名。 --&gt;\n&lt;property name=\"desc\" column=\"`desc`\" type=\"java.lang.String\"&gt;&lt;/property&gt;\n&lt;/class&gt;\n \n&lt;/hibernate-mapping&gt;</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<h2><strong>三、复合主键映射配置</strong></h2> \n<p></p> \n<pre code_snippet_id=\"2405133\" snippet_file_name=\"blog_20170519_2_9664699\" name=\"code\" class=\"java\">// 复合主键类\npublic class CompositeKeys implements Serializable{\nprivate String userName;\nprivate String address;\n   // .. get/set\n}\n \npublic class User {\n// 名字跟地址，不会重复\nprivate CompositeKeys keys;\nprivate int age;\n}</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<p></p> \n<pre code_snippet_id=\"2405133\" snippet_file_name=\"blog_20170519_3_9490759\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n \n&lt;hibernate-mapping package=\"cn.lfsenior.d_compositeKey\" auto-import=\"true\"&gt;\n&lt;class name=\"User\"&gt;\n&lt;!-- 复合主键映射 --&gt;\n&lt;composite-id name=\"keys\"&gt;\n&lt;key-property name=\"userName\" type=\"string\"&gt;&lt;/key-property&gt;\n&lt;key-property name=\"address\" type=\"string\"&gt;&lt;/key-property&gt;\n&lt;/composite-id&gt;\n&lt;property name=\"age\" type=\"int\"&gt;&lt;/property&gt;\n&lt;/class&gt;\n \n&lt;/hibernate-mapping&gt;</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<p></p> \n<pre code_snippet_id=\"2405133\" snippet_file_name=\"blog_20170519_4_2664106\" name=\"code\" class=\"java\">public class App2 {\nprivate static SessionFactory sf;\nstatic  {\n// 创建sf对象\nsf = new Configuration()\n.configure()\n.addClass(User.class)  //（测试） 会自动加载映射文件：Employee.hbm.xml\n.buildSessionFactory();\n}\n \n//1. 保存对象\n@Test\npublic void testSave() throws Exception {\nSession session = sf.openSession();\nTransaction tx = session.beginTransaction();\n// 对象\nCompositeKeys keys = new CompositeKeys();\nkeys.setAddress(\"广州棠东\");\nkeys.setUserName(\"Jack\");\nUser user = new User();\nuser.setAge(20);\nuser.setKeys(keys);\n// 保存\nsession.save(user);\ntx.commit();\nsession.close();\n}\n@Test\npublic void testGet() throws Exception {\nSession session = sf.openSession();\nTransaction tx = session.beginTransaction();\n//构建主键再查询\nCompositeKeys keys = new CompositeKeys();\nkeys.setAddress(\"广州棠东\");\nkeys.setUserName(\"Jack\");\n// 主键查询\nUser user = (User) session.get(User.class, keys);\n// 测试输出\nif (user != null){\nSystem.out.println(user.getKeys().getUserName());\nSystem.out.println(user.getKeys().getAddress());\nSystem.out.println(user.getAge());\n}\ntx.commit();\nsession.close();\n}\n}\n </pre>\n<br> \n<br> \n<p></p>',1,'原创','3169','一、映射配置 1. 普通字段类型 2. 主键映射 单列主键映射 多列作为主键映射   主键生成策略，查看api：   5.1.2.2.1. Various additional generators     3. 数据库： 一个表能否有多个主键？   不能。 为什么要设置主键？       数据库存储的数据都是有效的，必须保持唯一。   (为什么把id作为主键？) 因为表中通常找不到合适的列作为唯'),(16,'【Hibernate】Hibernate.cfg.xml 主配置','2017-05-19','<h2><strong>Hibernate.cfg.xml 主配置</strong></h2> \n<h3>1、Hibernate.cfg.xml</h3> \n<p>主配置文件中主要配置：数据库连接信息、其他参数、映射信息！</p> \n<p>&nbsp;</p> \n<h3>2、常用配置查看源码：</h3> \n<p>hibernate-distribution-3.6.0.Final\\project\\etc\\<span style=\"color:rgb(255,0,0)\">hibernate.properties</span></p> \n<p><strong><span style=\"color:rgb(255,0,0)\">&nbsp;</span></strong></p> \n<h3>3、数据库连接参数配置</h3> \n<p>例如：</p> \n<p>## MySQL</p> \n<p>#hibernate.dialect org.hibernate.dialect.MySQLDialect</p> \n<p>#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect</p> \n<p>#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect</p> \n<p>#hibernate.connection.driver_class com.mysql.jdbc.Driver</p> \n<p>#hibernate.connection.url jdbc:mysql:///test</p> \n<p>#hibernate.connection.username gavin</p> \n<p>#hibernate.connection.password</p> \n<p>&nbsp;</p> \n<h3>4、自动建表</h3> \n<p>Hibernate.properties</p> \n<p>&nbsp;</p> \n<p>#hibernate.hbm2ddl.auto <span style=\"color:rgb(255,0,0)\">create-drop</span>&nbsp;</p> \n<p><span style=\"font-family:楷体\">每次在创建</span>sessionFactory时候执行创建表；当调用sesisonFactory的close方法的时候，删除表！</p> \n<p>#hibernate.hbm2ddl.auto <span style=\"color:rgb(255,0,0)\">create</span>&nbsp;&nbsp;&nbsp;</p> \n<p><span style=\"font-family:楷体\">每次都重新建表；</span> <span style=\"font-family:楷体\">如果表已经存在就先删除再创建</span></p> \n<p>#hibernate.hbm2ddl.auto <span style=\"color:rgb(255,0,0)\">update &nbsp;</span></p> \n<p><span style=\"font-family:楷体\">如果表不存在就创建；</span> <span style=\"font-family:楷体\">表存在就不创建；</span></p> \n<p>#hibernate.hbm2ddl.auto <span style=\"color:rgb(255,0,0)\">validate &nbsp;</span></p> \n<p>(生成环境时候) 执行验证： 当映射文件的内容与数据库表结构不一样的时候就报错！</p> \n<p>&nbsp;</p> \n<h3>5、代码自动建表</h3> \n<p></p> \n<pre code_snippet_id=\"2405120\" snippet_file_name=\"blog_20170519_1_6919004\" name=\"code\" class=\"java\">public class App_ddl {\n// 自动建表\n@Test\npublic void testCreate() throws Exception {\n// 创建配置管理类对象\nConfiguration config = new Configuration();\n// 加载主配置文件\nconfig.configure();\n// 创建工具类对象\nSchemaExport export = new SchemaExport(config);\n// 建表\n// 第一个参数： 是否在控制台打印建表语句\n// 第二个参数： 是否执行脚本\nexport.create(true, true);\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<p>Bernate.cfg.xml配置文件:</p> \n<p></p> \n<pre code_snippet_id=\"2405120\" snippet_file_name=\"blog_20170519_2_1870257\" name=\"code\" class=\"html\">&lt;hibernate-configuration&gt;\n&lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt;\n&lt;session-factory&gt;\n&lt;!-- 1. 数据库连接配置 --&gt;\n&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hib_demo&lt;/property&gt;\n&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n&lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt;\n&lt;!--\n数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql\n --&gt;\n&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;\n&lt;!-- 2. 其他相关配置 --&gt;\n&lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt;\n&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;\n&lt;!-- 2.2 格式化sql --&gt;\n&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;\n&lt;!-- 2.3 自动建表  --&gt;\n&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;\n&lt;!-- 3. 加载所有映射 --&gt;\n&lt;mapping resource=\"cn/lfsenior/a_hello/Employee.hbm.xml\"/&gt;\n&lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;</pre>\n<br> \n<br> \n<p></p>',1,'原创','3742','Hibernate.cfg.xml 主配置 1、Hibernate.cfg.xml 主配置文件中主要配置：数据库连接信息、其他参数、映射信息！   2、常用配置查看源码： hibernate-distribution-3.6.0.Final\\project\\etc\\hibernate.properties   3、数据库连接参数配置 例如： ## MySQL #hibernate.dialect '),(17,'【Hibernate】crud','2017-05-19','<h2><strong>Hibernate crud</strong></h2> \n<h3>一、根据主键查询对象信息：</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_1_4245701\" name=\"code\" class=\"java\">public Employee findById(Serializable id) {\nSession session = null;\nTransaction tx = null;\ntry {\n// 获取Session\nsession = HibernateUtils.getSession();\n// 开启事务\ntx = session.beginTransaction();\n// 主键查询\nreturn (Employee) session.get(Employee.class, id);\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<h3>二、查询所有信息</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_2_625414\" name=\"code\" class=\"java\">public List&lt;Employee&gt; getAll() {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\n// HQL查询\nQuery q = session.createQuery(\"from Employee\");\nreturn q.list();\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}\n </pre>\n<br> \n<br> \n<p></p> \n<h3>三、根据姓名查询</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_3_7943218\" name=\"code\" class=\"java\">public List&lt;Employee&gt; getAll(String employeeName) {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\nQuery q =session.createQuery(\"from Employee where empName=?\");\n// 注意：参数索引从0开始\nq.setParameter(0, employeeName);\n// 执行查询\nreturn q.list();\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<h3>四、分页查询</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_4_5053279\" name=\"code\" class=\"java\">public List&lt;Employee&gt; getAll(int index, int count) {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\nQuery q = session.createQuery(\"from Employee\");\n// 设置分页参数\nq.setFirstResult(index);  // 查询的起始行\nq.setMaxResults(count);	  // 查询返回的行数\nList&lt;Employee&gt; list = q.list();\nreturn list;\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<p>&nbsp;</p> \n<h3>五、插入对象</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_5_3799543\" name=\"code\" class=\"java\">public void save(Employee emp) {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\n// 执行保存操作\nsession.save(emp);\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<h3>六、更新对象</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_6_9481144\" name=\"code\" class=\"java\">public void update(Employee emp) {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\nsession.update(emp);\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p> \n<h3>七、删除对象</h3> \n<p></p> \n<pre code_snippet_id=\"2405118\" snippet_file_name=\"blog_20170519_7_3003155\" name=\"code\" class=\"java\">public void delete(Serializable id) {\nSession session = null;\nTransaction tx = null;\ntry {\nsession = HibernateUtils.getSession();\ntx = session.beginTransaction();\n// 先根据id查询对象，再判断删除\nObject obj = session.get(Employee.class, id);\nif (obj != null) {\nsession.delete(obj);\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n} finally {\ntx.commit();\nsession.close();\n}\n}</pre>\n<br> \n<br> \n<p></p>',1,'原创','3237','Hibernate crud 一、根据主键查询对象信息： public Employee findById(Serializable id) {\nSession session = null;\nTransaction tx = null;\ntry {\n// 获取Session\nsession = HibernateUtils.getSession();\n// 开启事务\ntx = session.b'),(18,'【Hibernate】数据操作','2017-05-19','<h2><strong>Hibernate数据操作：</strong></h2> \n<h3>1、更新：</h3> \n<p><span style=\"color:rgb(255,0,0)\">session.save(obj); &nbsp;&nbsp;保存一个对象</span></p> \n<p><span style=\"color:rgb(255,0,0)\">session.update(emp); &nbsp;更新一个对象</span></p> \n<p><span style=\"color:rgb(255,0,0)\">session.saveOrUpdate(emp); &nbsp;保存或者更新的方法：</span></p> \n<p><span style=\"color:rgb(255,0,0)\">à</span><span style=\"color:rgb(255,0,0)\">没有设置主键，执行保存；</span></p> \n<p><span style=\"color:rgb(255,0,0)\">à</span><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">有设置主键，执行更新操作</span>;</span></p> \n<p><span style=\"color:rgb(255,0,0)\">à</span><span style=\"color:rgb(255,0,0)\">如果设置主键不存在报错！</span></p> \n<p><span style=\"color:rgb(255,0,0)\">&nbsp;</span></p> \n<h3>2、主键查询：</h3> \n<p><span style=\"color:rgb(255,0,0)\">session.get(Employee.class, 1); &nbsp;&nbsp;&nbsp;主键查询</span></p> \n<p><span style=\"color:rgb(255,0,0)\">session.load(Employee.class, 1); &nbsp;&nbsp;主键查询 (支持懒加载)</span></p> \n<p>&nbsp;</p> \n<h3>3、HQL查询：</h3> \n<p>HQL查询与SQL查询区别：</p> \n<p><strong>SQL</strong>: (结构化查询语句)查询的是表以及字段; &nbsp;不区分大小写。</p> \n<p><strong>HQL</strong>: hibernate &nbsp;query &nbsp;language 即hibernate提供的面向对象的查询语言</p> \n<p>查询的是对象以及对象的属性。</p> \n<p>区分大小写。</p> \n<p>&nbsp;</p> \n<h3>4、Criteria查询：</h3> \n<p>&nbsp;<span style=\"font-family:楷体\">完全面向对象的查询。</span></p> \n<p><span style=\"font-family:楷体\">本地</span>SQL查询：</p> \n<p><span style=\"font-family:楷体\">复杂的查询，就要使用原生态的</span>sql查询，也可以，就是本地sql查询的支持！</p> \n<p>(缺点： 不能跨数据库平台！)</p> \n<p>&nbsp;</p> \n<h3><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">共性问题</span>1：</span></h3> \n<p><span style=\"color:rgb(255,0,0)\">ClassNotFoundException…., 缺少jar文件！</span></p> \n<h3><span style=\"color:rgb(255,0,0)\">共性</span><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">问题</span>2：</span></h3> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">如果程序执行程序，</span>hibernate也有生成sql语句，但数据没有结果影响。</span></p> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">问题一般是事务忘记提交</span>…….</span></p> \n<p><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">遇到问题，一定看错误提示</span>!</span></p> \n<p>&nbsp;</p>',1,'原创','3054','Hibernate数据操作： 1、更新： session.save(obj);   保存一个对象 session.update(emp);  更新一个对象 session.saveOrUpdate(emp);  保存或者更新的方法： à没有设置主键，执行保存； à有设置主键，执行更新操作; à如果设置主键不存在报错！   2、主键查询： session.get(Employee.class, 1)'),(19,'【Hibernate】 Api','2017-05-19','<h2><strong>Hibernate &nbsp;Api：</strong></h2> \n<h3>|-- Configuration&nbsp;&nbsp;配置管理类对象<strong></strong></h3> \n<p><span style=\"color:rgb(0,0,255)\">config.configure()</span></p> \n<p><span style=\"font-family:楷体\">加载主配置文件的方法</span>(hibernate.cfg.xml)默认加载src/hibernate.cfg.xml</p> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">config.configure(“cn/config/hibernate.cfg.xml”)</span></p> \n<p align=\"justify\">加载指定路径下指定名称的主配置文件</p> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">config.buildSessionFactory()</span></p> \n<p align=\"justify\"><span style=\"font-family:楷体\">创建</span>session的工厂对象</p> \n<p align=\"justify\">&nbsp;</p> \n<h3>Configuration类负责管理Hibernate的配置信息。包括如下内容：</h3> \n<p align=\"justify\">1、Hibernate运行的底层信息：数据库的URL、用户名、密码、JDBC驱动类，数据库Dialect, <span style=\"font-family:楷体\"> 数据库连接池等（对应</span> hibernate.cfg.xml 文件）。</p> \n<p align=\"justify\">2、<span style=\"font-family:楷体\">持久化类与数据表的映射关系（</span>*.hbm.xml 文件）</p> \n<p align=\"justify\"><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">创建</span>Configuration 的两种方式</span></p> \n<p align=\"justify\">2.1、<span style=\"font-family:楷体\">属性文件（</span>hibernate.properties）:</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;Configuration cfg = new Configuration();</p> \n<p align=\"justify\">2.2、Xml文件（hibernate.cfg.xml）</p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;&nbsp;Configuration cfg = new Configuration().configure();</p> \n<p align=\"justify\">&nbsp;</p> \n<h3>|-- SchemaExport &nbsp;类主要负责根据类或者hbm文件映射生成持久化类对应的表结构<strong></strong></h3> \n<p><span style=\"color:rgb(0,0,255)\">create(boolean script, boolean export) </span> </p> \n<p align=\"justify\">&nbsp;&nbsp; <span style=\"font-family:楷体\">参数</span>1：是否生成脚本 &nbsp;参数2：是否导出到数据库</p> \n<p><span style=\"color:rgb(0,0,255)\"><span style=\"font-family:楷体\">创建</span>SchemaExport的方式</span></p> \n<p align=\"justify\">SchemaExport schema = new SchemaExport(config);</p> \n<p align=\"justify\">&nbsp;</p> \n<h3>|-- SessionFactory&nbsp;&nbsp;session的工厂（或者说代表了这个hibernate.cfg.xml配置文件）</h3> \n<p><span style=\"color:rgb(0,0,255)\">sf.openSession()</span></p> \n<p><span style=\"font-family:楷体\">创建一个</span>sesison对象</p> \n<p><span style=\"color:rgb(0,0,255)\">sf.getCurrentSession()</span></p> \n<p><span style=\"font-family:楷体\">创建</span>session或取出session对象</p> \n<p>&nbsp;</p> \n<h3>|--Session&nbsp;&nbsp;session对象维护了一个连接(Connection), 代表了与数据库连接的会话。</h3> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">session.beginTransaction()</span></p> \n<p>开启一个事务，hibernate要求所有的与数据库的操作必须有事务的环境，否则报错！</p> \n<p align=\"justify\">Session 类的方法：</p> \n<p align=\"justify\">取得持久化对象的方法：<span style=\"color:rgb(0,0,255)\">&nbsp;get() load()</span></p> \n<p align=\"justify\"><span style=\"font-family:楷体\">持久化对象都得保存，更新和删除：</span>s<span style=\"color:rgb(0,0,255)\">ave(),update(),saveOrUpdate(),delete()</span></p> \n<p align=\"justify\"><span style=\"font-family:楷体\">开启事务</span>: <span style=\"color:rgb(0,0,255)\"> beginTransaction().</span></p> \n<p align=\"justify\"><span style=\"font-family:楷体\">管理</span> Session 的方法：<span style=\"color:rgb(0,0,255)\">isOpen(),flush(), clear(), evict(), close()等</span></p> \n<p><u><span style=\"color:rgb(255,0,0)\">Hibernate最重要的对象</span><span style=\"color:rgb(255,0,0)\">，</span><span style=\"color:rgb(255,0,0)\"><span style=\"font-family:楷体\">只用使用</span>hibernate与数据库操作，都用到这个对象</span></u></p> \n<p>&nbsp;</p> \n<h3>|-- Transaction&nbsp;&nbsp;&nbsp;&nbsp;hibernate事务对象</h3> \n<p align=\"justify\"><span style=\"font-family:楷体\">代表一次原子操作，它具有数据库事务的概念。所有持久层都应该在事务管理下进行，即使是只读操作。</span></p> \n<p align=\"justify\">&nbsp;&nbsp;&nbsp;Transaction tx = session.beginTransaction();</p> \n<p align=\"justify\"><span style=\"font-family:楷体\">常用方法</span>:</p> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">commit():</span><span style=\"font-family:楷体\">提交相关联的</span>session实例</p> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">rollback():</span>撤销事务操作</p> \n<p align=\"justify\"><span style=\"color:rgb(0,0,255)\">wasCommitted():</span>检查事务是否提交</p> \n<p>&nbsp;</p> \n<p>&nbsp;</p>',1,'原创','3228','Hibernate  Api： |-- Configuration  配置管理类对象 config.configure() 加载主配置文件的方法(hibernate.cfg.xml)默认加载src/hibernate.cfg.xml config.configure(“cn/config/hibernate.cfg.xml”) 加载指定路径下指定名称的主配置文件 config.buildSessi'),(20,'【Hibernate】搭建一个Hibernate环境，开发步骤','2017-05-19','<h2><strong><span style=\"font-family:楷体\"></span></strong></h2> \n<h2><strong><span style=\"font-family:楷体\">搭建一个</span>Hibernate环境，开发步骤：</strong></h2> \n<h3>1. 下载源码</h3> \n<p><span style=\"font-family:楷体\">版本：</span>hibernate-distribution-3.6.0.Final</p> \n<h3>2. 引入jar文件</h3> \n<p><strong><span style=\"color:rgb(255,0,0)\">hibernate3.jar核心 &nbsp;+ &nbsp;required 必须引入的(6个) + &nbsp;jpa 目录 &nbsp;+ 数据库驱动包</span></strong></p> \n<h3>3. 写对象以及对象的映射</h3> \n<p><strong><span style=\"color:rgb(255,0,0)\">Employee.java &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象</span></strong></p> \n<p><strong><span style=\"color:rgb(255,0,0)\">Employee.hbm.xml &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象的映射 (映射文件)</span></strong></p> \n<h3>4. src/hibernate.cfg.xml &nbsp;主配置文件</h3> \n<p>-à&nbsp;<span style=\"font-family:楷体\">数据库连接配置</span></p> \n<p>-à&nbsp;<span style=\"font-family:楷体\">加载所用的映射</span>(*.hbm.xml)</p> \n<h3>5. App.java &nbsp;测试</h3> \n<p></p> \n<p><span style=\"color:rgb(192,0,0)\">Employee.java &nbsp;&nbsp;&nbsp;&nbsp;对象</span></p> \n<p></p> \n<pre code_snippet_id=\"2405088\" snippet_file_name=\"blog_20170519_1_8691641\" name=\"code\" class=\"java\">//一、 对象\npublic class Employee {\n\n	private int empId;\n	private String empName;\n	private Date workDate;\n	\n}</pre>\n<br> \n<p></p> \n<p><span style=\"color:rgb(192,0,0)\">Employee.hbm.xml &nbsp;对象的映射</span></p> \n<pre code_snippet_id=\"2405088\" snippet_file_name=\"blog_20170519_2_5135828\" name=\"code\" class=\"html\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \n	\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n	\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n\n&lt;hibernate-mapping package=\"cn.lfsenior.a_hello\"&gt;\n	\n	&lt;class name=\"Employee\" table=\"employee\"&gt;\n		\n		&lt;!-- 主键 ，映射--&gt;\n		&lt;id name=\"empId\" column=\"id\"&gt;\n			&lt;generator class=\"native\"/&gt;\n		&lt;/id&gt;\n		\n		&lt;!-- 非主键，映射 --&gt;\n		&lt;property name=\"empName\" column=\"empName\"&gt;&lt;/property&gt;\n		&lt;property name=\"workDate\" column=\"workDate\"&gt;&lt;/property&gt;\n		\n	&lt;/class&gt;\n\n&lt;/hibernate-mapping&gt;</pre>\n<br> \n<p><span style=\"color:rgb(192,0,0)\">hibernate.cfg.xml &nbsp;&nbsp;&nbsp;主配置文件</span></p> \n<pre code_snippet_id=\"2405088\" snippet_file_name=\"blog_20170519_3_3914329\" name=\"code\" class=\"html\">&lt;!DOCTYPE hibernate-configuration PUBLIC\n	\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n	\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n\n&lt;hibernate-configuration&gt;\n	&lt;session-factory&gt;\n		&lt;!-- 数据库连接配置 --&gt;\n		&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;\n		&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hib_demo&lt;/property&gt;\n		&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n		&lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt;\n		&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;\n		\n		&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;\n		\n		&lt;!-- 加载所有映射 --&gt;\n		&lt;mapping resource=\"cn/lfsenior/a_hello/Employee.hbm.xml\"/&gt;\n	&lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;</pre>\n<br> \n<p><span style=\"color:rgb(192,0,0)\">App.java &nbsp;&nbsp;测试类</span></p> \n<pre code_snippet_id=\"2405088\" snippet_file_name=\"blog_20170519_4_1820778\" name=\"code\" class=\"java\">public class App {\n\n	@Test\n	public void testHello() throws Exception {\n		// 对象\n		Employee emp = new Employee();\n		emp.setEmpName(\"班长\");\n		emp.setWorkDate(new Date());\n		\n		// 获取加载配置文件的管理类对象\n		Configuration config = new Configuration();\n		config.configure();  // 默认加载src/hibenrate.cfg.xml文件\n		// 创建session的工厂对象\n		SessionFactory sf = config.buildSessionFactory();\n		// 创建session (代表一个会话，与数据库连接的会话)\n		Session session = sf.openSession();\n		// 开启事务\n		Transaction tx = session.beginTransaction();\n		//保存-数据库\n		session.save(emp);\n		// 提交事务\n		tx.commit();\n		// 关闭\n		session.close();\n		sf.close();\n	}\n}</pre>\n<br>',1,'原创','3176','搭建一个Hibernate环境，开发步骤： 1. 下载源码 版本：hibernate-distribution-3.6.0.Final 2. 引入jar文件 hibernate3.jar核心  +  required 必须引入的(6个) +  jpa 目录  + 数据库驱动包 3. 写对象以及对象的映射 Employee.java            对象 Employee.hbm.xml   '),(21,'【Hibernate】ORM概念','2017-05-19','<h2><strong><span style=\"font-family:楷体\">一、</span>ORM概念</strong></h2> \n<p>O, &nbsp;Object &nbsp;对象</p> \n<p>R， Realtion 关系 &nbsp;(关系型数据库: MySQL, Oracle…)</p> \n<p>M，Mapping &nbsp;映射</p> \n<p>ORM：对象关系映射！</p> \n<p>&nbsp;</p> \n<h2><strong>二、ORM, 解决什么问题？</strong></h2> \n<p><strong><span style=\"font-family:楷体\">存储：</span> &nbsp;<span style=\"font-family:楷体\">能否把对象的数据直接保存到数据库？</span></strong></p> \n<p><strong><span style=\"font-family:楷体\">获取：</span> &nbsp;<span style=\"font-family:楷体\">能否直接从数据库拿到一个对象？</span></strong></p> \n<p><strong><span style=\"font-family:楷体\">想做到上面</span>2点，必须要有映射！</strong></p> \n<p><strong>&nbsp;</strong></p> \n<h2><strong>三、总结：</strong></h2> \n<p><strong>Hibernate与ORM的关系？</strong></p> \n<p><strong>&nbsp;&nbsp;&nbsp;Hibernate是ORM的实现！</strong></p> \n<p>&nbsp;</p> \n<p><img src=\"http://img.blog.csdn.net/20170519112107815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br> </p> \n<p><br> </p> \n<p>&nbsp;<img src=\"http://img.blog.csdn.net/20170519112112190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0NDg5NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p> \n<p>&nbsp;</p> \n<p>&nbsp;</p>',1,'原创','3093','一、ORM概念 O,  Object  对象 R， Realtion 关系  (关系型数据库: MySQL, Oracle…) M，Mapping  映射 ORM：对象关系映射！   二、ORM, 解决什么问题？ 存储：  能否把对象的数据直接保存到数据库？ 获取：  能否直接从数据库拿到一个对象？ 想做到上面2点，必须要有映射！   三、总结： Hibernate与ORM的关系？    Hibe'),(22,'org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update错误','2017-05-19','org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:92)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:66)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:275)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:268)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:188)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:321)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:51)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1216)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.impl.SessionImpl.managedFlush(SessionImpl.java:383)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.transaction.JDBCTransaction.commit(JDBCTransaction.java:133)\n<br> \n<span style=\"white-space:pre\"></span>at cn.lfsenior.entry.App.test2(App.java:37)\n<br> \n<span style=\"white-space:pre\"></span>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n<br> \n<span style=\"white-space:pre\"></span>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n<br> \n<span style=\"white-space:pre\"></span>at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n<br> \n<span style=\"white-space:pre\"></span>at java.lang.reflect.Method.invoke(Method.java:606)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n<br> \n<span style=\"white-space:pre\"></span>at org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n<br> \n<span style=\"white-space:pre\"></span>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n<br> Caused by: java.sql.BatchUpdateException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'index, address) values (7, 1, \'åŒ—äº¬\')\' at line 1\n<br> \n<span style=\"white-space:pre\"></span>at com.mysql.jdbc.PreparedStatement.executeBatchSerially(PreparedStatement.java:1693)\n<br> \n<span style=\"white-space:pre\"></span>at com.mysql.jdbc.PreparedStatement.executeBatch(PreparedStatement.java:1108)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:70)\n<br> \n<span style=\"white-space:pre\"></span>at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:268)\n<br> \n<span style=\"white-space:pre\"></span>... 31 more\n<br> \n<p><br> </p> \n<p><strong><span style=\"color:#ff0000\">出错原因：</span></strong></p> \n<p><strong><span style=\"color:#ff0000\">在映射的时候写的列名为“关键字”</span></strong></p>',1,'原创','3191','org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:92) at org.hibernate.exception.JDBCExceptio');
/*!40000 ALTER TABLE `blog_content` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_content_category`
--

DROP TABLE IF EXISTS `blog_content_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_content_category` (
  `content_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  KEY `FKCCB1DD0170D66019` (`category_id`),
  KEY `FKCCB1DD0159961C1B` (`content_id`),
  CONSTRAINT `FKCCB1DD0159961C1B` FOREIGN KEY (`content_id`) REFERENCES `blog_content` (`content_id`),
  CONSTRAINT `FKCCB1DD0170D66019` FOREIGN KEY (`category_id`) REFERENCES `blog_category` (`category_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_content_category`
--

LOCK TABLES `blog_content_category` WRITE;
/*!40000 ALTER TABLE `blog_content_category` DISABLE KEYS */;
INSERT INTO `blog_content_category` VALUES (1,2),(2,2),(3,2),(4,2),(5,2),(6,2),(7,2),(8,2),(9,2),(10,2),(11,2),(12,2),(13,2),(14,2),(15,2),(16,2),(17,2),(18,2),(19,2),(20,2),(21,2),(22,2);
/*!40000 ALTER TABLE `blog_content_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_user`
--

DROP TABLE IF EXISTS `blog_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(100) DEFAULT NULL,
  `user_age` int(11) DEFAULT NULL,
  `user_address` varchar(100) DEFAULT NULL,
  `user_gender` varchar(100) DEFAULT NULL,
  `user_descrip` varchar(200) DEFAULT NULL,
  `user_brith` date DEFAULT NULL,
  `user_email` varchar(100) DEFAULT NULL,
  `user_tel` varchar(100) DEFAULT NULL,
  `user_qq` varchar(100) DEFAULT NULL,
  `user_pwd` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_user`
--

LOCK TABLES `blog_user` WRITE;
/*!40000 ALTER TABLE `blog_user` DISABLE KEYS */;
INSERT INTO `blog_user` VALUES (1,'丁凌风',12,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
/*!40000 ALTER TABLE `blog_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-10-12 22:06:16
